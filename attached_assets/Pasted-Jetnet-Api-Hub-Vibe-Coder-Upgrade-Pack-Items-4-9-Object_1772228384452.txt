Jetnet-Api-Hub: Vibe Coder Upgrade Pack (Items 4–9)
Objective
Make Jetnet-Api-Hub feel “AI-native” and “ship-fast” for vibe coders by adding:
AI prompts that reliably generate working apps (4)
One-click starter templates (5)
Token/session logic that is self-healing and self-verifying using /getAccountInfo (6)
Response shaping guidance for UI devs (7)
A “choose your adventure” entry point (8)
Inline, contextual guardrails for common mistakes (9)
Non-Goals
Not rebuilding all examples.
Not building a full SDK with advanced features. Keep it small and composable.
Not changing existing docs structure unless additive.
Scope Overview
Deliverables (repo artifacts)
/prompts/ folder with 3–5 “build me this app” prompts (Item 4)
/templates/ folder with at least one Next.js template and one API backend template (Item 5)
Token TTL + auto-refresh strategy: add a minimal auth/session module and a token_probe utility using /getAccountInfo (Item 6)
docs/response-shapes.md (Item 7)
START_HERE.md + README “choose your path” hooks (Item 8)
Inline guardrails: update README + examples to embed gotchas at point-of-use (Item 9)
Item 6: Token / Session Handling (Use /getAccountInfo)
The goal
Stop vibe coders from getting stuck on “INVALID SECURITY TOKEN” and uncertainty about TTL.
The problem
Tokens expire.
“60 minutes” assumptions drift.
Engineers want a lightweight, safe endpoint to validate tokens without making heavy calls.
Devs often do not handle “application-level errors in JSON” (not just HTTP codes).
The information
Use /getAccountInfo as:
A cheap token health-check endpoint
A probe to observe effective TTL in practice
A way to confirm “session is still good” before long workflows
The solution
Implement:
A small session/auth helper in both Python and Node
A token “health check” that calls /getAccountInfo and triggers re-login once if invalid
A token_probe script that measures practical TTL by polling /getAccountInfo until failure
Engineering tasks
A) Add session helpers
Python
src/jetnet/session.py
login(email, password, base_url) -> SessionState
get_account_info(session_state) -> dict
ensure_session(session_state) -> SessionState (calls get_account_info; re-login once on invalid)
jetnet_request(method, path, session_state, json=None) -> dict
Node/TS
src/jetnet/session.ts
login()
getAccountInfo()
ensureSession()
jetnetRequest()
SessionState fields
baseUrl
email (optional, if re-login is required)
password (optional, if re-login is required)
bearerToken
apiToken
createdAt (ISO or epoch)
lastValidatedAt
B) Define token validation logic
Rules:
Before starting a multi-call workflow, call ensure_session().
If /getAccountInfo returns invalid token (or response indicates invalid), run login() once and retry /getAccountInfo.
If it fails again, hard error with a clear message.
C) Implement “application-level error” detection
Many Jetnet endpoints can return HTTP 200 but a JSON responsestatus indicates an error.
Standardize:
If response has responsestatus and it begins with "ERROR" or contains "INVALID" → treat as failure
If response has type/title/status (RFC error style) → treat as failure
Add a single normalize_error() helper to extract human-readable error messages
D) Add token_probe
Purpose: Determine practical TTL for this account.
scripts/token_probe.py
poll /getAccountInfo every 60 seconds (or 120)
record time from login to first failure
print results: “Observed token TTL: 57m 12s”
store result in ./.cache/token_probe.json (gitignored)
scripts/token_probe.ts optional, but Python is enough
E) Add docs and README snippet
Add in README:
“Assume tokens expire. We validate via /getAccountInfo and auto re-login once.”
“Run python scripts/token_probe.py to observe TTL for your tenant.”
Acceptance criteria (Item 6)
Fresh clone + .env + run any template works for at least 30 minutes without manual re-login
When token expires, the next call auto re-auths once and continues
token_probe produces a numeric TTL and a timestamped log
Item 4: Prompts Folder (“Copy/Paste to Cursor”)
The goal
Let vibe coders paste a prompt into Cursor/Copilot/ChatGPT and generate an app that matches Jetnet workflows.
The problem
Generic prompts produce half-working code, incorrect endpoint order, or missing auth/token logic.
The solution
Create prompt “recipes” with:
app description
required screens/components
exact API call sequence
response shaping requirements
error handling rules (including responsestatus)
caching rules (session + token)
definition of done
Folder structure
/prompts/
01_golden_path_tail_lookup_app.md
02_fbo_airport_activity_leads.md
03_fleet_watchlist_alerts.md
04_bulk_export_pipeline.md (optional but high value)
README.md (how to use prompts)
Prompt template (standard sections)
Every prompt must include:
App goal
UI screens
API workflow (ordered)
Response shaping contract (what objects UI expects)
Auth/session rules (must use /getAccountInfo validation)
Error rules
Definition of done
“Do not do” list (avoid hardcoding tokens, avoid committing .env, avoid ignoring responsestatus)
Acceptance criteria (Item 4)
Prompt pasted into an IDE agent can build a working minimal app without the user needing to infer endpoints
Prompt explicitly instructs the agent to use the repo session helpers + /getAccountInfo
Item 5: Templates Folder (One-Click Starter Apps)
The goal
“Run it and see something” without reading docs.
The problem
Examples are helpful, templates are what people actually ship from.
The solution
Add opinionated templates with:
.env.example
README.md that is 10 lines max
one key screen that demonstrates the Golden Path
uses session helper + /getAccountInfo
Minimum templates to ship
templates/nextjs-tail-lookup/
Tail input
Results: Aircraft Card, Owner/Operator summary, Utilization (if available)
Uses src/jetnet/session.ts
templates/python-fastapi-golden-path/
/lookup?tail=N12345
returns normalized response object
includes src/jetnet/session.py
Optional (high value):
3) templates/node-express-golden-path/
Acceptance criteria (Item 5)
npm install && npm run dev works after copying .env.example to .env
one request flow uses /getAccountInfo health-check automatically
Item 7: docs/response-shapes.md (UI-first response shaping)
The goal
Make it obvious what shape the UI should consume so engineers don’t spread Jetnet’s raw JSON everywhere.
The problem
Jetnet responses vary by endpoint and can include a mix of IDs, nested objects, and paging metadata. UI devs need stable “cards”.
The solution
Create a response contract and normalization patterns.
Required contents
docs/response-shapes.md must define these normalized objects:
1) AircraftCard
regNbr
serialNbr (if available)
make
model
year
aircraftId
operatorCompanyId (if available)
ownerCompanyId (if available)
2) CompanyCard
companyId
companyName
segment (optional)
location (city/state/country)
primaryPhone (optional)
3) GoldenPathResult
aircraft: AircraftCard
owner?: CompanyCard
operator?: CompanyCard
utilization?: { last12moHours?, last90DaysCycles?, trends? }
raw: { endpointsCalled: string[], timestamps: ... } (optional debug)
4) Error object
code
message
endpoint
rawResponsestatus (if present)
Also include:
“Mapping examples” from 2–3 Jetnet endpoints to these normalized objects
“Where people go wrong” section pointing to responsestatus handling
Acceptance criteria (Item 7)
Template apps return GoldenPathResult to the UI with zero Jetnet-specific coupling in components
Item 8: START_HERE.md + README “Choose Your Adventure”
The goal
Reduce overwhelm. Route users instantly to the correct path.
The problem
A rich repo can feel like “where do I begin”.
The solution
Add a single on-ramp doc and link it at the top of README.
START_HERE.md structure
Path A: “I want a demo UI in 5 minutes”
points to templates/nextjs-tail-lookup
Path B: “I want bulk/export data”
points to bulk export template or example + paging helper
Path C: “I want CRM enrichment”
points to a prompt + a backend template
Also include:
“What you need” checklist: credentials, baseUrl, token concepts
“How auth works” in 6 lines
“What endpoints return errors even when HTTP 200” in 2 lines
Acceptance criteria (Item 8)
A new user can land in the repo and get to a running template without scrolling
Item 9: Inline Guardrails (Common Mistakes at Point-of-Use)
The goal
Prevent the top 3 failures before they happen.
The problem
Vibe coders do not read “Common Mistakes” until they hit one.
The solution
Move guardrails to where people copy/paste:
README Quickstart
first login snippet
first paginated call
date examples
Must-add inline notes
Email casing
Explicitly show emailAddress casing in the login snippet (and warn against emailaddress mismatch).
Do not trust HTTP 200
For every “first call” example, add a 2-line snippet:
“Check responsestatus for ERROR before using response.events or response.data.”
Token placement
Emphasize: some endpoints use Bearer header, others include {apiToken} in the path; do not swap them.
Date format
Show the required format and explicitly call out month/day order.
Acceptance criteria (Item 9)
If a user copies the README login + one endpoint call, it includes:
error handling
responsestatus checks
token validation via /getAccountInfo
Suggested PR Plan (How Engineering Should Implement)
PR 1: Session + /getAccountInfo + token_probe (Item 6)
Add src/jetnet/session.*
Add scripts/token_probe.py
Add small README section: “Token validation strategy”
PR 2: Templates (Item 5)
Add templates/nextjs-tail-lookup
Add templates/python-fastapi-golden-path
Confirm both use session helpers
PR 3: Prompts (Item 4) + START_HERE (Item 8)
Add /prompts/*
Add START_HERE.md
Update README top links
PR 4: Response shapes + inline guardrails (Items 7, 9)
Add docs/response-shapes.md
Update README snippets + first examples
Definition of Done (All Items 4–9)
Repo has a clearly visible “Start Here” path.
At least one template app runs end-to-end with only .env changes.
Tokens are validated using /getAccountInfo and auto-refreshed once.
There is a documented normalized response contract for UIs.
Common mistakes are prevented by inline guardrails.
Prompts exist that reliably generate new apps in Cursor/Copilot using the same patterns.